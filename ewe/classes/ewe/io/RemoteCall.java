/*********************************************************************************
 *  Ewe Virtual Machine - Version 1.14, January 24, 2002                         *
 *  Copyright (C) 1999-2002 Michael L Brereton <michael_brereton@ewesoft.com>    *
 *  All Rights Reserved                                                          *
 *                                                                               *
 *  This library and virtual machine is free software; you can redistribute      *
 *  it and/or modify it under the terms of the Amended GNU Lesser General        *
 *  Public License distributed with this software.                               *
 *                                                                               *
 *  Under this license, linking this library or part thereof with other files to *
 *  produce an executable does not in itself require the executable to be        *
 *  covered by the GNU Lesser General Public License.                            *
 *                                                                               *
 *  This library and virtual machine is distributed in the hope that it will     *
 *  be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                         *
 *                                                                               *
 *  You should have received a copy of the License along with this software;     *
 *  if not, please download it at: www.ewesoft.com/LGPL.txt                      *
 *                                                                               *
 *********************************************************************************/
package ewe.io;
import ewe.reflect.Array;
import ewe.reflect.Constructor;
import ewe.reflect.Method;
import ewe.reflect.Reflect;
import ewe.reflect.Wrapper;
import ewe.util.ByteArray;
import ewe.util.ByteEncodable;
import ewe.util.ByteEncoder;
import ewe.util.Range;
import ewe.util.Vector;
/**
* A RemoteCall with a RemoteCallHandler can be used to invoke methods on an object
* running in one ewe application by a different remote application. The remote call
* handles marshalling the data into text streams which are then sent
* and reassembled into local data and invoked on the target object. A result
* is sent back indicating success or failure along with any return value. This is very
* useful when synchronizing ewe applications since you do not need to come up with any
* protocols or message passing system. All you need to do is invoke methods remotely.
* <p>
* See the EweSyncDemo application for an example of how to do this.
* <p>
* Please note the following restrictions when using remote calls.
* <ul>
* <li>All individual Object parameters or objects within arrays or vectors must be text
* encodable/decodable in some way.
* </li>
* </ul>
*
* <p>A RemoteCall represents a single method which is specified in its constructor.
* Once you have a RemoteCall object you set parameters for a call by calling the
* add() methods in sequence. The RemoteCall knows the exact type of each parameter
* so the data specified in each add() method is cast to the correct parameter type.
* Each add() method returns the RemoteCall object itself so it is easy to concatenate
* add() calls together.
**/

//##################################################################
public class RemoteCall extends ewe.sys.Handle implements ByteEncodable{
//##################################################################

public String method;
public String retType = "";
public String id;
Vector parameters = new Vector();

String [] types;
//String [] actual;
//String [] values;

/**
* This is used if you intend to send/receive parameters that are classes that are loaded using
* a non-system class loader.
* @deprecated - this is not needed.
**/
public Class classCreator;
/**
* This will hold any exception generated by the remote object when the
* method was invoked. If the exception generated on the remote side
* could not be recreated on this side - it will be set to RemoteCall.UnknownException
and the message will be set to be the same.
**/
public Throwable invocationError;
/**
* This is the timeout for the call. By default it is zero, which will then let the remote call handler
* being used to send the call use its own timeout.
**/
public int timeOut = 0;

/**
* This is initially null but can be set before calling call.
**/
public RemoteCallHandler myHandler;

//##################################################################
public static class UnknownException extends Exception{
//##################################################################

public UnknownException() {super();}
public UnknownException(String message) {super(message);}
//===================================================================
//public UnknownException(Throwable cause) {super(cause);}
//===================================================================
//public UnknownException(String message,Throwable cause) {super(message,cause);}
//===================================================================

//##################################################################
}
//##################################################################

private int curPar = 0;
/**
* Create a new RemoteCall targeted at the specified method. Parameter
* and return specs MUST be provided e.g.<br><br>
* new RemoteCall("aMethod(IILjava/lang/String;)Z");<p>
* Standard Java type specifiers are used, specifically.
* <p>
* B - byte, C - char, S - short, I - int, J - long, F - float, D - Double
* Z - boolean, V - void (for method types only)<br>
* [<i>type-specifier</i> - for an array.<br>
* L<i>className</i>; - for object (NOTE the ending semi-colon).<p>
* For object (L) you should use / instead of . as the package separator.
* <p>
* The format for a method is: <i>method_name</i>(<i>concatenated parameter type specifiers</i>)<i>return_type</i>
* <p>
* There are no separators between the parameter type specifiers. If the the method is void you should
* use V as the return type.
**/
//===================================================================
public RemoteCall(String method)
//===================================================================
{
	setMethod(method);
}
/**
* This is used to create a RemoteCall from a sequence of bytes. This is used
* by the handler to reconstruct the call after it has been received.
**/
//===================================================================
public RemoteCall(byte[] source,int offset,int length)
throws StreamCorruptedException, ClassNotFoundException
//===================================================================
{
	decodeBytes(source,offset,length);
}
/**
 * Get a copy of a RemoteCall that you can use for another invocation. RemoteCalls should
	only be used once to invoke on the remote object - so if you want to invoke the call
	repeatedly you will need to call this method. However after doing so you will always need
	to add the parameters again.
 * @return A copy of the RemoteCall with no parameters added yet.
 */
//===================================================================
public RemoteCall getCopy()
//===================================================================
{
	return new RemoteCall(method);
}
/**
 * This is used to set a special class creator. This is in case you are going to be
	sending/receiving objects that were loaded from a non-system class loader. The creator
	supplied must have been loaded from the same class loader.
 * @param creator A Class object that was loaded from the same class loader.
 * @return this RemoteCall
 * @deprecated, this is no longer needed - ClassLoaders are cached by mClassLoader
 * and used by the ByteEncoder to create them as needed.
 */
//===================================================================
public RemoteCall setClassCreator(Class creator)
//===================================================================
{
	classCreator = creator;
	return this;
}
//-------------------------------------------------------------------
private void setMethod(String method)
//-------------------------------------------------------------------
{
	this.method = method;
	types = Reflect.getParameters(Reflect.getMethodParameterList(method));
	int idx = method.indexOf(')');
	if (idx != -1) retType = method.substring(idx+1);
	//actual = new String[types.length];
	//values = new String[types.length];
}
//-------------------------------------------------------------------
private char getCurType()
//-------------------------------------------------------------------
{
	try{
		return types[parameters.size()].charAt(0);
	}catch(IndexOutOfBoundsException e){
		throw new IllegalStateException("Too many parameters.");
	}
}
/**
 * This is used to add a parameter.
 * @param w a Wrapper with the parameter value. It must be of the correct type.
 * @return this RemoteCall object.
 */
//===================================================================
public RemoteCall addParameter(Wrapper w)
//===================================================================
{
	char type = getCurType();
	if (w.getType() != getCurType()) throw new IllegalArgumentException("Incompatible parameter");
	parameters.add(w);
	return this;
}
/**
* Use this to add a char parameter.
* @param value The character parameter
* @return itself.
*/
//===================================================================
public RemoteCall add(char value)
//===================================================================
{
	return add((long)value);
}
/**
* Use this to add a parameter of type byte, short, int and long.
* @param value The long value to add.
* @return itself.
*/
//===================================================================
public RemoteCall add(long value)
//===================================================================
{
	Wrapper w = new Wrapper();
		switch(getCurType()){
			case 'B' : w.setByte((byte)value); break;
			case 'S' : w.setShort((short)value); break;
			case 'C' : w.setChar((char)value); break;
			case 'I' : w.setInt((int)value); break;
			case 'J' : w.setLong(value); break;
			case 'Z' : w.setBoolean(value != 0); break;
			default:
				throw new IllegalArgumentException("Incompatible parameter");
		}
		return addParameter(w);
}
/**
* Use this to add a parameter of type float or double.
* @param value The double or float value to add.
* @return itself.
*/
//===================================================================
public RemoteCall add(double value)
//===================================================================
{
	Wrapper w = new Wrapper();
		switch(getCurType()){
			case 'D' : w.setDouble(value); break;
			case 'F' : w.setFloat((float)value); break;
			default:
				throw new IllegalArgumentException("Incompatible parameter");
		}
		return addParameter(w);
}
/**
* Use this to add a parameter of type boolean.
* @param value The boolean value to add.
* @return itself.
*/
//===================================================================
public RemoteCall add(boolean value)
//===================================================================
{
	return add(value ? 1 : 0);
}
/**
* Use this to add an object or array parameter (including null).
* @param value The object or array value to add.
* @return itself.
*/
//===================================================================
public RemoteCall add(Object value)
//===================================================================
{
	Wrapper w = new Wrapper();
		switch(getCurType()){
			case 'L' : w.setObject(value); break;
			case '[' :
				if (value != null && !Array.isArray(value))
					throw new IllegalArgumentException("Incompatible parameter");
				w.setArray(value);
				break;
			default:
				throw new IllegalArgumentException("Incompatible parameter");
		}
		return addParameter(w);
}
//===================================================================
public RemoteCall set(Wrapper[] parameters)
//===================================================================
{
	for (int i = 0; i<parameters.length; i++)
		addParameter(parameters[i]);
	return this;
}
//===================================================================
public int encodeBytes(ByteArray dest) throws IllegalStateException
//===================================================================
{
	if (parameters.size() != types.length) throw new IllegalStateException("All the parameters have not been set.");
	ByteArray ba = new ByteArray();
	int total = ByteEncoder.encodeField(dest,"<m>",method);
	for (int i = 0; i<parameters.size(); i++)
		ByteEncoder.encode(ba,(Wrapper)parameters.get(i));
	total += ByteEncoder.encodeField(dest,"<p>",ba.data,0,ba.length);
	return total;
}
//-------------------------------------------------------------------
private int decodeBytes(byte[] source,int offset,int length)
throws StreamCorruptedException, ClassNotFoundException
//-------------------------------------------------------------------
{
	if (source == null) return length;
	method = ByteEncoder.decodeStringField(source,offset,length,"<m>");
	Range r = ByteEncoder.getFieldByteArray(source,offset,length,"<p>",null);
	Wrapper[] all = ByteEncoder.decode(source,r.first,r.last-r.first+1);
	parameters = new Vector(all);
	return length;
}
/**
* This encodes the call ready for dispatch. You would not need to use this unless you
* were writing a RemoteCallHandler.
* @param dest The destination TextEncoder or null if you want the method to create and return a new one.
* @return The TextEncoder parameter or a new one if it is null.
*/
/*
//===================================================================
public TextEncoder encode(TextEncoder dest) throws IllegalStateException
//===================================================================
{
	if (curPar != types.length) throw new IllegalStateException("The parameters have not been set.");
	if (dest == null) dest = new TextEncoder();
	dest.addValue("<method>",method);
	for (int i = 0; i<types.length; i++)
		dest.addValue(actual[i] == null ? "" : actual[i], values[i] == null ? "" : values[i]);
	return dest;
}
*/


/**
* Invoke the remote call on a target object of the specified class.
* You would not need to use this unless you were writing a RemoteCallHandler.
* @param dest The destination Object to invoke the method on - can be
* @param r The Reflect object for the destination Object.
* @return An encoded return value.
*/
/*
//===================================================================
public TextEncoder invokeOn(Object dest,Reflect r)
//===================================================================
{
	TextEncoder te = new TextEncoder();
	if (!invokeOn(dest,r,te))
		te.addValue("<error>","Error executing method.");
	return te;
}
*/
//===================================================================
public ByteArray invokeOn(Object dest,Reflect r)
//===================================================================
{
	ByteArray ba = new ByteArray();
	if (!invokeOn(dest,r,ba))
		ByteEncoder.encodeField(ba,"<err>","Error");
	return ba;
}
//-------------------------------------------------------------------
private boolean returnException(Throwable t,ByteArray dest)
//-------------------------------------------------------------------
{
	ByteEncoder.encodeField(dest,"<ex>",t.getClass().getName());
	String message = t.getMessage();
	if (message != null) ByteEncoder.encodeField(dest,"<em>",message);
	return false;
}
//-------------------------------------------------------------------
protected boolean invokeOn(Object dest,Reflect r,ByteArray ba)
//-------------------------------------------------------------------
{
	try{
		if (ba == null) ba = new ByteArray();
		if (r == null) r = Reflect.getForObject(dest);
		if (r == null) return false;
		int idx = method.indexOf('(');
		if (idx == -1) return false;
		Method md = r.getMethod(method.substring(0,idx),method.substring(idx),0);
		if (md == null)
			return returnException(new NoSuchMethodError(method),ba);
		Wrapper [] p = new Wrapper[parameters.size()];
		parameters.copyInto(p);
		Wrapper got = md.invoke(dest,p,null);
		if (md.invocationError != null)
			return returnException(md.invocationError,ba);
		else{
	 		ByteEncoder.encodeField(ba,"<OK>","");
			if (md.returnsValue())
	 			ByteEncoder.encodeField(ba,"<ret>",got);
		}
		return true;
	}finally{
	}
}
/**
* This is used to tell the RemoteCall that it is in the process of transmission
* to the remote object.
* You would not need to use this unless you were writing a RemoteCallHandler.
**/
//===================================================================
public void sent()
//===================================================================
{
	set(Running);
}
/**
 * This sets the timeout time for this RemoteCall. This overrides the timeout of the
 * remote call handler being used to send the call.
 * @param milliseconds the timeout in milliseconds. Setting it to zero will cause the
 * remote call handler timeout to be used instead.
 * @return this RemoteCall.
 */
//===================================================================
public RemoteCall setTimeout(int milliseconds)
//===================================================================
{
	timeOut = milliseconds;
	return this;
}
/**
* This is used to tell the RemoteCall that no reply has been received past a
* timeout period and it should conisider itself timed out.
* You would not need to use this unless you were writing a RemoteCallHandler.
**/
/*
//===================================================================
public void timeout()
//===================================================================
{
	failed(new ewe.sys.TimedOutException("Operation Timed Out"));
}
*/
/**
* This is set true once a reply has been received.
**/
//===================================================================
public boolean replied = false;
//===================================================================

//-------------------------------------------------------------------
private static String get(ByteArray ba,String name)
//-------------------------------------------------------------------
{
	try{
		return (String)ByteEncoder.decodeObjectField(ba.data,0,ba.length,name,null);
	}catch(Exception e){
		return null;
	}
}
/**
* This is used to provide a reply to the remote call. It will then prepare
* the return value Wrapper and set its flags to be successfull.
* You would not need to use this unless you were writing a RemoteCallHandler.
**/
//===================================================================
public void reply(ByteArray reply)
//===================================================================
{
	try{
		error = get(reply,"<err>");
		if (error == null){
			try{
				returnValue = ByteEncoder.decodeField(reply.data,0,reply.length,"<ret>",null);
				set(Succeeded);
			}catch(Exception e){}
		}else{
			String ex = get(reply,"<ex>");
			if (ex != null){
				String msg = get(reply,"<em>");
				Reflect r = Reflect.loadForName(ex);
				if (r == null){
					invocationError = new UnknownException(ex+(msg == null ? "" : (" - "+msg)));
				}else{
					Constructor c = r.getConstructor(msg == null ? "()V" : "(Ljava/lang/String;)V",r.PUBLIC);
					if (c == null) invocationError = new UnknownException(ex+(msg == null ? "" : (" - "+msg)));
					else{
						Wrapper [] inv = new Wrapper[msg == null ? 0 : 1];
						if (msg != null) inv[0] = new Wrapper().setObject(msg);
						invocationError = (Throwable)c.newInstance(inv);
						if (invocationError == null) invocationError = new UnknownException(ex+(msg == null ? "" : (" - "+msg)));
					}
				}
				failed(new RemoteCallException(this,invocationError,null));
			}
		}
	}finally{
		replied = true;
		setFlags(Stopped,0);
	}
}
/**
 * Invokes the remote call using the specified handler as the transport mechanism.
 * @param handler the RemoteCallHandler handling the call.
 * @param targetCode the target object.
 * @return a Wrapper containing the return value. Use getInt(), getDouble(), getObject(), etc. on the
	returned value to convert to the appropriate type.
 * @exception RemoteCallException if an error occured during the RemoteCall.
 */
//===================================================================
public Wrapper call(RemoteCallHandler handler,String targetCode) throws RemoteCallException
//===================================================================
{
	StringBuffer error = new StringBuffer();
	Wrapper ret = handler.call(this,targetCode,error);
	if (ret == null) throw new RemoteCallException(this,invocationError,error.toString());
	return ret;
}
//===================================================================
public RemoteCall callAsync(RemoteCallHandler handler,String targetCode)
//===================================================================
{
	if (handler == null) handler = myHandler;
	myHandler.call(this,targetCode);
	return this;
}
//===================================================================
public RemoteCall callAsync()
//===================================================================
{
	return callAsync(myHandler,null);
}
//===================================================================
public Wrapper getReturnValue()
//===================================================================
{
	return (Wrapper)returnValue;
}
//===================================================================
public Throwable getException()
//===================================================================
{
	return invocationError;
}
/**
 * Invokes the remote call using the myHandler value as the transport mechanism.
 * @param targetCode the target object.
 * @return a Wrapper containing the return value. Use getInt(), getDouble(), getObject(), etc. on the
	returned value to convert to the appropriate type. A Wrapper is always returned, even if
	the method is a void method.
 * @exception RemoteCallException if an error occured during the RemoteCall.
 */
//===================================================================
public Wrapper call(String targetCode) throws RemoteCallException
//===================================================================
{
	if (myHandler == null) throw new IllegalStateException("RemoteCallHandler not set.");
	return call(myHandler,targetCode);
}
/**
 * Invokes the remote call using the myHandler value as the transport mechanism and specifying a null (default) target object.
 * The method waits until the call returns.
 * @return a Wrapper containing the return value. Use getInt(), getDouble(), getObject(), etc. on the
	returned value to convert to the appropriate type. A Wrapper is always returned, even if
	the method is a void method.
 * @exception RemoteCallException if an error occured during the RemoteCall.
 */
//===================================================================
public Wrapper call() throws RemoteCallException
//===================================================================
{
	if (myHandler == null) throw new IllegalStateException("RemoteCallHandler not set.");
	return call(myHandler,null);
}
/**
* Create a remote call from a received encoded call. You would not use this
* unless you were writing your own RemoteCallHandler.
**/
/*
//===================================================================
public RemoteCall(TextDecoder from)
//===================================================================
{
	setMethod(from.getValue("<method>"));
	int sz = from.size();
	int t = 0;
	for(int i = 0; i<sz; i++){
		String v = from.getName(i);
		if (v != null)
			if (v.length() > 0)
				if (v.charAt(0) == '<')
					continue;
		actual[t] = v;
		values[t] = from.getValue(i);
		t++;
	}
}
*/
//===================================================================
public String toString()
//===================================================================
{
	return method;
}
//##################################################################
}
//##################################################################

